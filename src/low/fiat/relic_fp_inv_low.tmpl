/*
 * RELIC is an Efficient LIbrary for Cryptography
 * Copyright (C) 2007-2020 RELIC Authors
 *
 * This file is part of RELIC. RELIC is legal property of its developers,
 * whose names are not listed here. Please refer to the COPYRIGHT file
 * for contact information.
 *
 * RELIC is free software; you can redistribute it and/or modify it under the
 * terms of the version 2.1 (or later) of the GNU Lesser General Public License
 * as published by the Free Software Foundation; or version 2.0 of the Apache
 * License as published by the Apache Software Foundation. See the LICENSE files
 * for more details.
 *
 * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the LICENSE files for more details.
 *
 * You should have received a copy of the GNU Lesser General Public or the
 * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>
 * or <https://www.apache.org/licenses/>.
 */

/**
 * @file
 *
 * Implementation of the low-level prime field addition and subtraction
 * functions.
 *
 * @ingroup fp
 */

#include <gmp.h>

#include "relic_fp.h"
#include "relic_fp_low.h"
#include "relic_core.h"

/*============================================================================*/
/* Public definitions                                                         */
/*============================================================================*/

#define WORD dig_t
#define LIMBS RLC_FP_DIGS
#define LEN_PRIME FP_PRIME
#define WORDSIZE RLC_DIG
#define CURVE_DESCRIPTION fiat_fp

#include "fiat_fp.c"

//#define FP_INT DIVST

#if FP_INT == DIVST

#define MAKE_FN_NAME1(x,y) x ## y
#define MAKE_FN_NAME(x,y) MAKE_FN_NAME1(x,y)

#define PRECOMP MAKE_FN_NAME(CURVE_DESCRIPTION,_divstep_precomp)
#define MSAT MAKE_FN_NAME(CURVE_DESCRIPTION,_msat)
#define MONE MAKE_FN_NAME(CURVE_DESCRIPTION,_set_one)
#define DIVSTEP MAKE_FN_NAME(CURVE_DESCRIPTION,_divstep)
#define OPP MAKE_FN_NAME(CURVE_DESCRIPTION,_opp)
#define MUL MAKE_FN_NAME(CURVE_DESCRIPTION,_mul)
#define FROM_MONTGOMERY MAKE_FN_NAME(CURVE_DESCRIPTION,_from_montgomery)
#define SELECT MAKE_FN_NAME(CURVE_DESCRIPTION, _selectznz)

#if LEN_PRIME < 46
#define ITERATIONS (((49 * LEN_PRIME) + 80) / 17)
#else
#define ITERATIONS (((49 * LEN_PRIME) + 57) / 17)
#endif

#define SAT_LIMBS (((LEN_PRIME - 1) / WORDSIZE) + 2) /* we might need 2 more bits to represent m in twos complement */
#define BYTES (((LEN_PRIME - 1) / 8) + 1)

void fp_invm_low(WORD *c, const WORD *a) {

  WORD precomp[LIMBS];
  PRECOMP(precomp);

  WORD d = 1;
  WORD f[SAT_LIMBS];
  WORD g[SAT_LIMBS];
  WORD v[LIMBS];
  WORD r[LIMBS];
  WORD out1;
  WORD out2[SAT_LIMBS], out3[SAT_LIMBS], out4[LIMBS], out5[LIMBS];

  FROM_MONTGOMERY(g, a);
  g[SAT_LIMBS - 1] = 0;

  MSAT(f);
  MONE(r);
  for (int j = 0; j < LIMBS; j++) v[j] = 0;

  for (int i = 0; i < ITERATIONS - (ITERATIONS % 2); i+=2) {
    DIVSTEP(&out1,out2,out3,out4,out5,d,f,g,v,r);
    DIVSTEP(&d,f,g,v,r,out1,out2,out3,out4,out5);
  }
  if (ITERATIONS % 2) {
    DIVSTEP(&out1,out2,out3,out4,out5,d,f,g,v,r);
    for (int k = 0; k < LIMBS; k++) v[k] = out4[k];
    for (int k = 0; k < SAT_LIMBS; k++) f[k] = out2[k];
  }

  WORD h[LIMBS];
  OPP(h, v);
  SELECT(v, out2[RLC_FP_DIGS - 1] >> (WORDSIZE - 1), out4, h);
  MUL(c, v, precomp);
  return;
}

#elif FP_INT == JUMPDS

#define MAKE_FN_NAME1(x,y) x ## y
#define MAKE_FN_NAME(x,y) MAKE_FN_NAME1(x,y)

#define PRECOMP MAKE_FN_NAME(CURVE_DESCRIPTION,_jumpdivstep_precomp)
#define DIVSTEP MAKE_FN_NAME(CURVE_DESCRIPTION,_twos_complement_word_full_divstep)
#define SHIFTR MAKE_FN_NAME(CURVE_DESCRIPTION,_asr_mw_sub2)
#define SIGNED_TO_MONTGOMERY MAKE_FN_NAME(CURVE_DESCRIPTION,_twos_complement_word_to_montgomery_no_encode)
#define SAT_ADD MAKE_FN_NAME(CURVE_DESCRIPTION,_sat_add)
#define WORD_SAT_MUL MAKE_FN_NAME(CURVE_DESCRIPTION,_word_sat_mul)
#define MSAT MAKE_FN_NAME(CURVE_DESCRIPTION,_msat)
#define ADD MAKE_FN_NAME(CURVE_DESCRIPTION,_add)
#define MUL MAKE_FN_NAME(CURVE_DESCRIPTION,_mul)
#define OPP MAKE_FN_NAME(CURVE_DESCRIPTION,_opp)
#define FROM_MONTGOMERY MAKE_FN_NAME(CURVE_DESCRIPTION,_from_montgomery)

#if LEN_PRIME < 46
#define ITERATIONS (((49 * LEN_PRIME) + 80) / 17)
#else
#define ITERATIONS (((49 * LEN_PRIME) + 57) / 17)
#endif

#define SAT_LIMBS LIMBS + 1 /* we might need 2 more bits to represent m in twos complement */
#define WORD_SAT_MUL_LIMBS LIMBS + 2 /* we might need 1 more limb to represent a word/multilimb multiplication */
#define BYTES (((LEN_PRIME - 1) / 8) + 1)

#define INNER_LOOP (WORDSIZE - 2)
#define OUTER_LOOP (ITERATIONS / INNER_LOOP) + 1

void fp_invm_low(WORD *c, const WORD *a) {

  WORD precomp[LIMBS];
  PRECOMP(precomp);

  WORD d = 1;
  WORD f[SAT_LIMBS];
  WORD g[SAT_LIMBS];
  WORD v[LIMBS];
  WORD r[LIMBS];
  WORD f0, g0, u0, v0, q0, r0, out1, out2, out3, out4, out5, out6, out7;

  FROM_MONTGOMERY(g, a);
  g[SAT_LIMBS - 1] = 0;

  MSAT(f);
  for (int i = 0; i < LIMBS; i++) r[i] = 0;
  r[0] = 1;

  for (int j = 0; j < LIMBS; j++) v[j] = 0;

  for (int i = 0; i < OUTER_LOOP; i++) {
    u0 = 1;
    v0 = 0;
    q0 = 0;
    r0 = 1;

    f0 = f[0];
    g0 = g[0];
    for (int j = 0; j < INNER_LOOP; j += 2) {
      DIVSTEP(&out1, &out2, &out3, &out4, &out5, &out6, &out7, d, f0, g0, u0, v0, q0, r0);
      DIVSTEP(&d, &f0, &g0, &u0, &v0, &q0, &r0, out1, out2, out3, out4, out5, out6, out7);
    }
    WORD f1[WORD_SAT_MUL_LIMBS], f2[WORD_SAT_MUL_LIMBS], f3[WORD_SAT_MUL_LIMBS], g1[WORD_SAT_MUL_LIMBS], g2[WORD_SAT_MUL_LIMBS], g3[WORD_SAT_MUL_LIMBS];
    WORD_SAT_MUL(f1, u0, f);
    WORD_SAT_MUL(f2, v0, g);
    WORD_SAT_MUL(g1, q0, f);
    WORD_SAT_MUL(g2, r0, g);

    SAT_ADD(f3, f1, f2);
    SAT_ADD(g3, g1, g2);

    WORD f4[WORD_SAT_MUL_LIMBS], g4[WORD_SAT_MUL_LIMBS];
    SHIFTR(f4, f3);
    SHIFTR(g4, g3);

    for (int k = 0; k < SAT_LIMBS; k++) {
      f[k] = f4[k];
      g[k] = g4[k];
    }

	WORD u1[LIMBS], v01[LIMBS], q1[LIMBS], r01[LIMBS];

    SIGNED_TO_MONTGOMERY(u1, u0);
    SIGNED_TO_MONTGOMERY(v01, v0);
    SIGNED_TO_MONTGOMERY(q1, q0);
    SIGNED_TO_MONTGOMERY(r01, r0);

    WORD v1[LIMBS], v2[LIMBS], r1[LIMBS], r2[LIMBS];
    MUL(v1, u1, v);
    MUL(v2, v01, r);
    MUL(r1, q1, v);
    MUL(r2, r01, r);

    ADD(v, v1, v2);
    ADD(r, r1, r2);
  }

  WORD h[LIMBS];
  if (f[SAT_LIMBS - 1] >> (WORDSIZE - 1)) {
    OPP(h, v);
    for (int l = 0; l < LIMBS; l++) v[l] = h[l];
  }

  MUL(c, v, precomp);

  return;
}

#else

#define MAKE_FN_NAME1(x,y) x ## y
#define MAKE_FN_NAME(x,y) MAKE_FN_NAME1(x,y)

#define PRECOMP MAKE_FN_NAME(CURVE_DESCRIPTION,_jumpdivstep_precomp)
#define MSAT MAKE_FN_NAME(CURVE_DESCRIPTION,_msat)
#define MUL MAKE_FN_NAME(CURVE_DESCRIPTION,_mul)
#define OPP MAKE_FN_NAME(CURVE_DESCRIPTION,_opp)

#define BODY MAKE_FN_NAME(CURVE_DESCRIPTION,_outer_loop_body)

#if LEN_PRIME < 46
#define ITERATIONS (((49 * LEN_PRIME) + 80) / 17)
#else
#define ITERATIONS (((49 * LEN_PRIME) + 57) / 17)
#endif

#define SAT_LIMBS (((LEN_PRIME - 1) / WORDSIZE) + 2) /* we might need 2 more bits to represent m in twos complement */
#define BYTES (((LEN_PRIME - 1) / 8) + 1)

#define INNER_LOOP (WORDSIZE - 2)
#define OUTER_LOOP ((ITERATIONS / INNER_LOOP) + 1)

void fp_invm_low(WORD *c, const WORD *a) {

  WORD precomp[LIMBS];
	PRECOMP(precomp);

  WORD f1[SAT_LIMBS], f[SAT_LIMBS], g[SAT_LIMBS], g1[SAT_LIMBS];
  WORD v1[LIMBS], v[LIMBS];
  WORD r1[LIMBS], r[LIMBS];

  FROM_MONTGOMERY(g, a);
  g[SAT_LIMBS - 1] = 0;

  MSAT(f);
  for (int i = 0; i < LIMBS; i++) r[i] = 0;
  r[0] = 1;

  for (int j = 0; j < LIMBS; j++) v[j] = 0;

  for (int i = 0; i < OUTER_LOOP - (OUTER_LOOP % 2); i+=2) {
    BODY(f1,g1,v1,r1,f,g,v,r);
    BODY(f,g,v,r,f1,g1,v1,r1);
  }
  if (OUTER_LOOP % 2) {
    BODY(f1,g1,v1,r1,f,g,v,r);
    for (int k = 0; k < LIMBS; k++) v[k] = v1[k];
    for (int k = 0; k < SAT_LIMBS; k++) f[k] = f1[k];
  }

  WORD h[LIMBS];
  if (f[SAT_LIMBS - 1] >> (WORDSIZE - 1)) {
    OPP(h, v);
    for (int l = 0; l < LIMBS; l++) v[l] = h[l];
  }

  MUL(out, v, precomp);

  return;
}

#endif
